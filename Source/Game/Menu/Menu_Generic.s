;********************************
; MENU_GENERIC.S
;********************************
;	Author:	Dylan ExoByte Mayo
;	(c)2000	Interactive Imagination
;	All rights reserved
;SEE MENU_MAC.S FOR DETAILS
;********************************
;A SHOULD STILL HAVE THE (CNTDOWN) STUFF
?MENU_CURSOR_CROSS_UPDATE

	SRL		A	
	SRL		A		
	SRL		A		;SHIFT A DOWN SO THE KEYS ARE 
	SRL		A		;4 LSBS
	
	LD		HL,MENU_CURSOR_ENTRY_R		;START OF DIR CODES
	
	LD		C,3
_LUPE1
	BIT		0,A
	JR		NZ,_CHANGE_ID
	INC		HL
	SRL		A
	DEC 	C
	JR		NZ,_LUPE1
	
_CHANGE_ID
	LD		A,(HL)
	LD		(MENU_CURSOR_ID),A
	
	PUSH	HL
	CALL	?MENU_UPDATE_CURSOR
	POP		DE
		
	SWITCH_RAM_BANK		(MENU_VALID_BANK)
	FGET16	H,L,MENU_VALID_ARRAY
	LD		A,H
	OR		L					;IF M_V_A IS 0, JUST RET
	JR		Z,_ACTOR_CHECK
	
	LD		A,(MENU_CURSOR_ID)	;ELSE SEE IF ON VALID POS
	LD		C,A
	LD		B,0
	ADD		HL,BC
	LD		A,(HL)
	CP		0
	JR		NZ,_ACTOR_CHECK			;IF VALID, WE'RE DONE
	
	LD		H,D
	LD		L,E
	JR		_CHANGE_ID			;ELSE MOVE IN THAT DIR AGAIN	

_ACTOR_CHECK
	LD		A,(MENU_CURSORTYPE)
	CP		MENU_CURSOR_ACTOR
	RET		NZ
	
	CALL	?MENU_DRAW_CURSROR_ACTOR
	
	RET
	
;********************************	
?MENU_DONE
	
	FGET16		H,L,MENU_BGCURSOR_OLD
	LD			A,TEXT_BOX_BLANK
	LD			(HL),A	
	
	FGET16		H,L,MENU_BGCURSOR_NEW
	LD			A,TEXT_BOX_BLANK
	LD			(HL),A	
	
	RET

;********************************
?MENU_DRAW_CURSROR_ACTOR

;ADJUST CURSOR FOR COORDS->SCREEN	
	LD		A,(MENU_CURSOR_ENTRY_X)
	INC 	A
	
	ADD		A,A	; MULT8
	ADD		A,A
	ADD		A,A
	
	LD		(ACTOR0A_XTILE),A
	
	LD		A,(MENU_CURSOR_ENTRY_Y)
	INC		A
	INC		A
	
	ADD		A,A	; MULT8
	ADD		A,A
	ADD		A,A
	
	LD		(ACTOR0A_YTILE),A	

	RET

;********************************
?MENU_DRAW_CURSOR_BG

	;CURRENT "NEW" CURSOR BECOMES "OLD"
	LD		HL,MENU_BGCURSOR_OLD
	LD		BC,MENU_BGCURSOR_NEW
	
	LD_HLI_BCI
	LD_HLI_BCI
	
	MOVADDR	VBLANK_FUNC,?MENU_DRAW_CURSOR_BG_VBLANK
	LD			A,MENU_BANK
	LD			(VBLANK_BANK),A	
	
	;DETERMINE IF WE NEED TO UPDATE THE BG
	;ALSO IF IN ALWAYS DRAW MODE, USE CURSOR2
	LD		A,TEXT_BOX_CURSOR2
	LD		(MENU_CURSOR_VRAM),A
	
	LD		A,(MENU_CONFIRM)
	CP		1
	JR		Z,_CONFIRM_DRAW
	
	LD		A,(MENU_BLINK_FLAG)
	CP		MENU_CURSOR_NOBLINK
	JR		Z,_CONFIRM_DRAW
	
	LD		A,TEXT_BOX_CURSOR1
	LD		(MENU_CURSOR_VRAM),A
	
;ACTUAL BLINK
	LD		HL,MENU_BLINK
	LD		A,(HL)
	INC		A
	CP		$1F
	JR		NZ,_NO_RESET
	XOR		A
_NO_RESET
	LD		(HL),A
	CP		$F
	JR		NC,_CONFIRM_DRAW
	LD		A,TEXT_BOX_BLANK
	LD		(MENU_CURSOR_VRAM),A
	RET
	
_CONFIRM_DRAW
	LD		A,(MENU_CURSOR_ENTRY_Y)
	SUB	 	13
	LD		L,A
	LD		H,0
	
	;MULT Y-13 COORD BY 32 (-13 FOR BOX OFFSET)
	SLA16	H,L,5
	
	;ADD	X
	LD		A,(MENU_CURSOR_ENTRY_X)
	LD		C,A
	LD		B,0
	ADD		HL,BC
	
	;ADD 9C00, BASE OF BG2
	LD		BC,$9C00
	ADD		HL,BC
	
;	;SAVE THIS VAL FOR LATER
;	PUSH	HL
;	
;	;NOW SEE IF WE'RE IN THE SAME SPOT
;	GET16	B,C,MENU_BGCURSOR_OLD
;	TWOS_COMP	B,C
;	ADD		HL,BC
;	LD		A,H
;	OR		L
;	POP		HL
;	RET		Z
	
	SET16	H,L,MENU_BGCURSOR_NEW
	
	RET	
	
;********************************
?MENU_DRAW_CURSOR_BG_VBLANK

	;THESE 2 VARS WILL BE $0000 IF THEY ARE "GONE"
	FGET16		H,L,MENU_BGCURSOR_OLD	
;	LD			A,H
;	OR			L
;	JR			Z,_CLEAR1
	LD			A,TEXT_BOX_BLANK
	LD			(HL),A
		
_CLEAR1
	FGET16		H,L,MENU_BGCURSOR_NEW
;	LD			A,H
;	OR			L
;	RET			Z
	LD			A,(MENU_CURSOR_VRAM)
	LD			(HL),A
	
	MOVADDR	VBLANK_FUNC,?VBLANK_IDLE

	RET

;********************************
?MENU_DRAW_CURSOR_SPRITE
;BLINK THE CURSOR CODE
;FIRST CHECK FOR THE CONFIRM FLAG, 
;IF THE CONFIRM FLAG IS SET, DON'T BLINK ALWAYS DRAW

;ALSO IF IN ALWAYS DRAW MODE, USE CURSOR2
	LD		A,TEXT_BOX_CURSOR2
	LD		(MENU_CURSOR_VRAM),A

	LD		A,(MENU_CONFIRM)
	CP		1
	JR		Z,_CONFIRM_DRAW
	
	LD		A,(MENU_BLINK_FLAG)
	CP		MENU_CURSOR_NOBLINK
	JR		Z,_CONFIRM_DRAW
	
	LD		A,TEXT_BOX_CURSOR1
	LD		(MENU_CURSOR_VRAM),A
	
;ACTUAL BLINK
	LD		HL,MENU_BLINK
	LD		A,(HL)
	INC		A
	CP		$1F
	JR		NZ,_NO_RESET
	XOR		A
_NO_RESET
	LD		(HL),A
	CP		$F
	RET		C
	
_CONFIRM_DRAW
;ADJUST CURSOR FOR COORDS->SCREEN	
	LD		A,(MENU_CURSOR_ENTRY_X)
	INC 	A
	
	ADD		A,A	; MULT8
	ADD		A,A
	ADD		A,A
	
;SETUP STUFF FOR ?FRAME_DRAW_CHAR:  B,C,D,E	
	LD		B,A
	LD		A,(MENU_CURSOR_ENTRY_Y)
	INC		A
	INC		A
	
	ADD		A,A	; MULT8
	ADD		A,A
	ADD		A,A
	
	LD		C,A	
	LD		A,(MENU_CURSOR_VRAM)		;VRAM TILE OF CURSOR
	LD		D,A
	LD		E,%00001001					;FLAGS
		
	CALL	?FRAME_DRAW_CHR	

_NO_DRAW		

	RET
	

	
;********************************
?MENU_GO!

	LD		A,(MENU_CURSORTYPE)
	CP		MENU_CURSOR_SPRITE
	JR		Z,_SPRITE
	
	CP		MENU_CURSOR_ACTOR
	JR		Z,_KEY
	
	CALL	?MENU_DRAW_CURSOR_BG	
	JR		_KEY
	
_ACTOR
	CALL	?MENU_DRAW_CURSROR_ACTOR
	JR		_KEY
	
_SPRITE
	CALL	?MENU_DRAW_CURSOR_SPRITE
	
_KEY
	CALL	?MENU_KEY_CHECK
	
	RET
	
;********************************
?MENU_GO_CLOBBER

	FRAME_READY
	
	LD		A,(MENU_CURSORTYPE)
	CP		MENU_CURSOR_SPRITE
	JR		Z,_SPRITE
	
	CP		MENU_CURSOR_ACTOR
	JR		Z,_KEY
	
	CALL	?MENU_DRAW_CURSOR_BG	
	JR		_KEY
	
_ACTOR
	CALL	?MENU_DRAW_CURSROR_ACTOR
	JR		_KEY
	
_SPRITE
	CALL	?MENU_DRAW_CURSOR_SPRITE
	
_KEY	
	CALL	?MENU_KEY_CHECK
	
	RET
	
;********************************
?MENU_INIT

	LD			BC,0
	FSET16		B,C,MENU_BGCURSOR_OLD
	FSET16		B,C,MENU_BGCURSOR_NEW
	
	LD			A,TEXT_BOX_CURSOR1
	LD			(MENU_CURSOR_VRAM),A
	
	LD			A,(MENU_INIT_INDEX)
	LD			C,A
	LD			B,0
	LD			HL,MENU_GENERIC_TABLES
	ADD			HL,BC
	ADD			HL,BC				;*2 FOR PROPER OFFSET
	LD			A,(HLI)
	LD			H,(HL)
	LD			L,A	
	SET16		H,L,MENU_CURSOR_TABLE
	
	XOR			A
	LD			(MENU_BLINK),A			;BLINK = 0
	LD			(MENU_CONFIRM),A		;CONFIRM = 0
	
	CALL		?MENU_UPDATE_CURSOR
	
	;MAKE SURE YOU START ON A VALID ENTRY	
	
_CHANGE_ID
	SWITCH_RAM_BANK		(MENU_VALID_BANK)
	FGET16	H,L,MENU_VALID_ARRAY
	LD		A,H
	OR		L					;IF M_V_A IS 0, JUST RET
	JR		Z,_ACTOR_CHECK
	
	LD		A,(MENU_CURSOR_ID)	;ELSE SEE IF ON VALID POS
	LD		C,A
	LD		B,0
	ADD		HL,BC
	LD		A,(HL)
	CP		0
	JR		NZ,_ACTOR_CHECK					;IF VALID, WE'RE DONE
	
	LD		A,(MENU_CURSOR_ENTRY_R)
	LD		(MENU_CURSOR_ID),A	
	
	CALL	?MENU_UPDATE_CURSOR
	
	JR		_CHANGE_ID			;ELSE MOVE IN THAT DIR AGAIN	
	
_ACTOR_CHECK
	LD		A,(MENU_CURSORTYPE)
	CP		MENU_CURSOR_ACTOR
	RET		NZ
	
	CALL	?MENU_DRAW_CURSROR_ACTOR
	
	RET	

	
;********************************
?MENU_KEY_CHECK

	LD			A,(CNTDOWN)					;KEY CHECK
	LD			B,A
	LD			A,(MENU_KEY_MASK)
	AND			B
	LD			B,A							;FOR ?MAIN_MENU_KEY_AB

_CHECK_SEL
	BIT			BitSelect,A
	JR			Z,_CHECK_A					;IF WE DO ANYTHING W/ SELECT
	GET16		H,L,MENU_SELECT_FUNC			;DO WHATEVER WE WANT HERE
	JP			(HL)
	
_CHECK_A
	BIT			BitA,A
	JR			Z,_CHECK_B					;IF WE DO ANYTHING W/ A
	LD			A,(MENU_CURSOR_ENTRY_A)
	ADD			A,A
	LD			E,A
	LD			D,0
	LD			HL,MENU_FUNC_PTR_TABLE
	ADD			HL,DE
	ECALL_HL								;DO WHATEVER WE WANT HERE
	JR			_KEY_DONE
		
_CHECK_B
	BIT			BitB,A
	JR			Z,_CHECK_DIR				;IF WE DO ANYTHING W/ B
	LD			A,(MENU_CURSOR_ENTRY_B)
	ADD			A,A
	LD			E,A
	LD			D,0
	LD			HL,MENU_FUNC_PTR_TABLE
	ADD			HL,DE
	ECALL_HL								;DO WHATEVER WE WANT HERE
	JR			_KEY_DONE
	
;CHECK THE CONFIRM FLAG FIRST.
;IF WE'RE CONFIRMING A SELECTION
;NO CURSOR MOVEMENT FOR YOU
;NO OVERALL MENU BAILING EITHER W/ START
_CHECK_DIR
	LD			B,A
	LD			A,(MENU_CONFIRM)
	CP			1
	RET			Z
	LD			A,B
	
;_CHECK_RIGHT
	BIT			BitRight,A
	JR			Z,_CHECK_LEFT				;IF WE DO ANYTHING W/ RIGHT
	CALL		?MENU_CURSOR_CROSS_UPDATE	;DO WHATEVER WE WANT HERE
	JR			_KEY_DONE
	
_CHECK_LEFT
	BIT			BitLeft,A
	JR			Z,_CHECK_UP					;IF WE DO ANYTHING W/ LEFT
	CALL		?MENU_CURSOR_CROSS_UPDATE	;DO WHATEVER WE WANT HERE
	JR			_KEY_DONE
		
_CHECK_UP
	BIT			BitUp,A
	JR			Z,_CHECK_DOWN				;IF WE DO ANYTHING W/ UP
	CALL		?MENU_CURSOR_CROSS_UPDATE	;DO WHATEVER WE WANT HERE
	JR			_KEY_DONE
		
_CHECK_DOWN
	BIT			BitDown,A
	JR			Z,_CHECK_START				;IF WE DO ANYTHING W/ DOWN
	CALL		?MENU_CURSOR_CROSS_UPDATE	;DO WHATEVER WE WANT HERE
	JR			_KEY_DONE

	
_CHECK_START
	BIT			BitStart,A					;BACK TO THE GAME ON START
	RET			Z
	LD			HL,MENU_START_FUNC
	ECALL_HL

_KEY_DONE		

	RET	
	
;********************************
?MENU_TEXT_UPDATE

	MENU_TEXTUPDATE_NOSCRIPT _LOOP

	RET
	
;********************************
;
?MENU_UPDATE_CURSOR

;UPDATE X,Y POS

	LD		A,(MENU_CURSOR_ID)
	LD		L,A
	LD		H,$00
	ADD		HL,HL
	ADD		HL,HL
	ADD		HL,HL		;MULT *8 FOR PROPER OFFSET
	
	GET16	B,C,MENU_CURSOR_TABLE
	ADD		HL,BC
	
	LD		BC,MENU_CURSOR_ENTRY_X		;START CURRENT CURSOR STRUCT
	LD_BCI_HLI							;X
	LD_BCI_HLI							;Y
	LD_BCI_HLI							;R
	LD_BCI_HLI							;L
	LD_BCI_HLI							;U
	LD_BCI_HLI							;D
	LD_BCI_HLI							;A
	LD_BCI_HLI							;B	
	
	RET
		
;********************************
;A  VRAM TILE
;HL START IN BG
;DE	HL'S INC
;C  HOW MANY
?MENU_VRAM_TO_BG
	
	LD		(HL),A
	ADD		HL,DE
	INC		A
	DEC		C
	JR		NZ,?MENU_VRAM_TO_BG

	RET	

		
;********************************
	END
;********************************
